#!/usr/bin/env node

/**
 * DNS Resolver Classification Utility
 *
 * Tests DNS resolvers against a corpus of categorized domains to determine
 * which family (freedom, paranoia, adblock, family) they belong to.
 */

const fs = require('fs');
const path = require('path');
const { Command } = require('commander');
const dnsPacket = require('@dnsquery/dns-packet');

// Load test domains
const DOMAINS_FILE = path.join(__dirname, 'test-domains.json');
let domains = JSON.parse(fs.readFileSync(DOMAINS_FILE, 'utf8'));

// Optionally fetch live malware domains from URLhaus
async function fetchLiveMalwareDomains(count = 10) {
  try {
    const response = await fetch('https://urlhaus.abuse.ch/downloads/hostfile/', {
      signal: AbortSignal.timeout(10000)
    });

    if (!response.ok) return null;

    const text = await response.text();
    const lines = text.split('\n');
    const malwareDomains = [];

    for (const line of lines) {
      // Skip comments and empty lines
      if (line.startsWith('#') || !line.trim()) continue;

      // Parse hostfile format: "127.0.0.1 domain.com"
      const parts = line.trim().split(/\s+/);
      if (parts.length >= 2 && parts[0] === '127.0.0.1') {
        malwareDomains.push(parts[1]);
        if (malwareDomains.length >= count) break;
      }
    }

    return malwareDomains.length > 0 ? malwareDomains : null;
  } catch (error) {
    return null; // Silently fail and use fallback domains
  }
}

// Setup CLI
const program = new Command();

program
  .name('classifyResolver')
  .description('Classify DNS resolvers based on their filtering behavior')
  .version('1.0.0')
  .argument('<resolver-url>', 'DNS resolver URL to test (e.g., https://dns.google/dns-query)')
  .option('-v, --verbose', 'Show detailed output for each domain test', false)
  .option('-p, --protocol <type>', 'Protocol to use (doh or dot)', 'doh')
  .option('-j, --json', 'Output results as JSON', false)
  .option('-t, --timeout <ms>', 'Query timeout in milliseconds', '5000')
  .option('-c, --concurrency <num>', 'Number of parallel queries', '5')
  .option('--no-live-malware', 'Disable live malware domain fetching (use static test domains)')
  .addHelpText('after', `
Examples:
  $ classifyResolver https://dns.google/dns-query
  $ classifyResolver https://cloudflare-dns.com/dns-query --verbose
  $ classifyResolver https://family.cloudflare-dns.com/dns-query --json
  $ classifyResolver https://adblock.mydns.network/dns-query -v
`);

program.parse();

const options = program.opts();
const resolverUrl = program.args[0];

// Global options
const verbose = options.verbose;
const jsonOutput = options.json;
const queryTimeout = parseInt(options.timeout);
const concurrency = parseInt(options.concurrency);

// DNS query functions using @dnsquery/dns-packet
async function queryDoH(resolver, domain) {
  try {
    // Create DNS query using dns-packet
    const query = dnsPacket.encode({
      type: 'query',
      id: Math.floor(Math.random() * 65535),
      flags: dnsPacket.RECURSION_DESIRED,
      questions: [{
        type: 'A',
        name: domain
      }]
    });

    const base64Query = Buffer.from(query).toString('base64url');

    const url = new URL(resolver);
    url.searchParams.set('dns', base64Query);

    const response = await fetch(url.toString(), {
      headers: {
        'Accept': 'application/dns-message',
        'User-Agent': 'mydns-classifier/1.0'
      },
      signal: AbortSignal.timeout(queryTimeout)
    });

    if (!response.ok) {
      return { error: `HTTP ${response.status}` };
    }

    const arrayBuffer = await response.arrayBuffer();
    const answer = dnsPacket.decode(Buffer.from(arrayBuffer));

    // Check response code
    if (answer.rcode === 'NXDOMAIN') {
      return { blocked: true, reason: 'NXDOMAIN' };
    }

    if (answer.rcode === 'SERVFAIL') {
      return { blocked: true, reason: 'SERVFAIL' };
    }

    if (answer.rcode !== 'NOERROR') {
      return { blocked: true, reason: `RCODE ${answer.rcode}` };
    }

    // Check if we got answers
    if (!answer.answers || answer.answers.length === 0) {
      return { blocked: true, reason: 'No answer' };
    }

    // Check for block page IPs
    const aRecords = answer.answers.filter(a => a.type === 'A');
    if (aRecords.length > 0) {
      const ip = aRecords[0].data;
      if (ip === '0.0.0.0' || ip === '127.0.0.1' || ip.startsWith('0.') || ip === '::') {
        return { blocked: true, reason: 'Block page IP', ip };
      }
      return { blocked: false, ip };
    }

    return { blocked: false };
  } catch (error) {
    // Distinguish between timeout and other errors
    if (error.name === 'TimeoutError' || error.message.includes('timeout')) {
      return { error: 'Timeout' };
    }
    return { error: error.message };
  }
}

async function testDomain(resolver, domain, category) {
  if (verbose) {
    process.stdout.write(`  Testing ${domain.padEnd(30)} ... `);
  }

  const result = await queryDoH(resolver, domain);

  if (result.error) {
    if (verbose) console.log(`‚ùå Error: ${result.error}`);
    return { domain, category, error: result.error };
  }

  if (verbose) {
    if (result.blocked) {
      console.log(`üö´ Blocked (${result.reason})`);
    } else {
      console.log(`‚úÖ Resolved`);
    }
  }

  return { domain, category, blocked: result.blocked, reason: result.reason };
}

async function classifyResolver(resolver) {
  if (!jsonOutput) {
    console.log(`\nüîç Testing resolver: ${resolver}\n`);
  }

  // Dynamically create results object from domains
  const results = {};
  for (const category of Object.keys(domains)) {
    results[category] = { tested: 0, blocked: 0, errors: 0 };
  }

  const details = [];

  // Test each category (with parallel requests for better performance)
  for (const [category, testDomains] of Object.entries(domains)) {
    if (verbose) console.log(`\nüìã Testing ${category} domains:`);

    // Run queries in parallel batches for optimal performance
    for (let i = 0; i < testDomains.length; i += concurrency) {
      const batch = testDomains.slice(i, i + concurrency);
      const batchResults = await Promise.all(
        batch.map(domain => testDomain(resolver, domain, category))
      );

      // Process results
      for (const result of batchResults) {
        details.push(result);
        results[category].tested++;
        if (result.error) {
          results[category].errors++;
        } else if (result.blocked) {
          results[category].blocked++;
        }
      }
    }
  }

  // Calculate percentages (exclude errors from calculation)
  const percentages = {};
  for (const [category, stats] of Object.entries(results)) {
    const successful = stats.tested - stats.errors;
    // Only calculate if we have enough successful queries
    if (successful >= 3) {
      percentages[category] = (stats.blocked / successful * 100).toFixed(1);
    } else if (successful > 0) {
      // Mark low sample size with negative value
      percentages[category] = -(stats.blocked / successful * 100).toFixed(1);
    } else {
      // No successful queries - can't determine
      percentages[category] = 'N/A';
    }
  }

  // Classify based on blocking patterns
  let classification = 'unknown';
  let confidence = 0;

  // Helper to safely parse percentages (handles 'N/A' and negative values)
  const parsePercentage = (val) => {
    if (val === 'N/A') return 0;
    const num = parseFloat(val);
    return isNaN(num) ? 0 : Math.abs(num);
  };

  // Dynamically parse all percentages into a Map based on available categories
  const blocked = new Map(
    Object.keys(domains).map(category => [
      category,
      parsePercentage(percentages[category])
    ])
  );

  // Helper to check if condition matches
  const checkCondition = (condition) => {
    if (condition.min !== undefined && condition.max !== undefined) {
      const value = blocked.get(condition.category) || 0;
      return value >= condition.min && value <= condition.max;
    }
    if (condition.min !== undefined) {
      return (blocked.get(condition.category) || 0) >= condition.min;
    }
    if (condition.max !== undefined) {
      return (blocked.get(condition.category) || 0) < condition.max;
    }
    return false;
  };

  // Define classification rules (evaluated in order)
  const classificationRules = [
    {
      name: 'broken',
      confidence: 'high',
      description: 'Blocks legitimate services',
      conditions: [
        { category: 'benign', min: 20 },
        { category: 'cdn', min: 20 },
        { category: 'streaming', min: 30 },
        { category: 'news', min: 20 },
        { category: 'tech', min: 20 },
        { category: 'ecommerce', min: 20 },
        { category: 'finance', min: 20 }
      ],
      matchAny: true
    },
    {
      name: 'paranoia',
      confidence: 'high',
      description: 'Blocks tracking heavily, may block some legitimate services',
      conditions: [
        { category: 'tracking', min: 80 },
        { category: 'social', min: 60 },
        { category: 'ads', min: 80 }
      ]
    },
    {
      name: 'family',
      confidence: 'high',
      description: 'Blocks adult + gambling + torrents, may block social',
      conditions: [
        { category: 'adult', min: 80 },
        { category: 'gambling', min: 60 },
        { category: 'torrents', min: 60 }
      ]
    },
    {
      name: 'family',
      confidence: 'medium',
      description: 'Blocks adult content',
      conditions: [
        { category: 'adult', min: 80 },
        { category: 'gambling', min: 40 }
      ]
    },
    {
      name: 'adblock',
      confidence: 'high',
      description: 'Blocks ads/tracking but not adult content or torrents',
      conditions: [
        { category: 'ads', min: 60 },
        { category: 'tracking', min: 40 },
        { category: 'adult', max: 20 },
        { category: 'torrents', max: 20 }
      ]
    },
    {
      name: 'adblock',
      confidence: 'medium',
      description: 'Blocks some ads/tracking',
      conditions: [
        { category: 'ads', min: 40 },
        { category: 'adult', max: 20 }
      ]
    },
    {
      name: 'freedom',
      confidence: 'high',
      description: 'Minimal blocking (only malware/phishing/security)',
      conditions: [
        { category: 'adult', max: 20 },
        { category: 'ads', max: 20 },
        { category: 'gambling', max: 20 },
        { category: 'torrents', max: 20 },
        { category: 'social', max: 20 }
      ]
    }
  ];

  // Calculate total error rate to determine if we have enough data
  const totalErrors = Object.values(results).reduce((sum, r) => sum + r.errors, 0);
  const totalTests = Object.values(results).reduce((sum, r) => sum + r.tested, 0);
  const errorRate = totalTests > 0 ? totalErrors / totalTests : 1;

  // If error rate is too high (>50%), classification is unreliable
  if (errorRate > 0.5) {
    classification = 'unreliable';
    confidence = 'none';
  } else {
    // Evaluate rules in order
    for (const rule of classificationRules) {
      const matchAll = rule.matchAny !== true;
      const matches = rule.conditions.map(checkCondition);

      if ((matchAll && matches.every(m => m)) || (!matchAll && matches.some(m => m))) {
        classification = rule.name;
        confidence = rule.confidence;
        break;
      }
    }
  }

  const output = {
    resolver,
    classification,
    confidence,
    percentages,
    results,
    details: jsonOutput ? details : undefined
  };

  if (jsonOutput) {
    console.log(JSON.stringify(output, null, 2));
  } else {
    // Print results
    console.log('\n' + '='.repeat(60));
    console.log('üìä RESULTS');
    console.log('='.repeat(60));
    console.log('');

    // Define category groupings for better organization
    const categoryGroups = {
      'Content Filtering': ['adult', 'gambling', 'torrents'],
      'Privacy & Advertising': ['ads', 'tracking'],
      'Security': ['malware', 'phishing'],
      'Social & Communication': ['social', 'vpn'],
      'Legitimate Services': ['benign', 'cdn', 'streaming', 'news', 'tech', 'ecommerce', 'finance']
    };

    // Display labels for categories
    const categoryLabels = {
      adult: 'Adult',
      gambling: 'Gambling',
      torrents: 'Torrents',
      ads: 'Ads',
      tracking: 'Tracking',
      malware: 'Malware',
      phishing: 'Phishing',
      social: 'Social Media',
      vpn: 'VPN Services',
      benign: 'Benign',
      cdn: 'CDN',
      streaming: 'Streaming',
      news: 'News',
      tech: 'Tech',
      ecommerce: 'E-commerce',
      finance: 'Finance'
    };

    // Find any categories not in predefined groups
    const allGroupedCategories = Object.values(categoryGroups).flat();
    const ungroupedCategories = Object.keys(domains).filter(cat => !allGroupedCategories.includes(cat));
    if (ungroupedCategories.length > 0) {
      categoryGroups['Other'] = ungroupedCategories;
    }

    // Print each group dynamically
    for (const [groupName, categories] of Object.entries(categoryGroups)) {
      console.log(groupName + ':');
      for (const category of categories) {
        if (results[category]) {
          const label = (categoryLabels[category] || category.charAt(0).toUpperCase() + category.slice(1)) + ':';
          const successful = results[category].tested - results[category].errors;
          console.log(`  ${label.padEnd(17)} ${results[category].blocked}/${successful} blocked (${percentages[category]}%)`);
        }
      }
      console.log('');
    }

    console.log(`Classification:  ${classification.toUpperCase()}`);
    console.log(`Confidence:      ${confidence.toUpperCase()}`);
    console.log('');

    // Errors summary (totalErrors and totalTests already calculated above)
    const errorRatePercent = ((totalErrors / totalTests) * 100).toFixed(1);

    if (totalErrors > 0) {
      console.log(`‚ö†Ô∏è  ${totalErrors}/${totalTests} queries failed (${errorRatePercent}% error rate)`);
      if (errorRate > 0.5) {
        console.log(`‚ùå  Error rate too high - classification unreliable`);
      } else if (errorRate > 0.3) {
        console.log(`‚ö†Ô∏è  High error rate may affect classification accuracy`);
      }
      console.log('');
    }
  }

  return output;
}

// Fetch live malware domains if not disabled
(async () => {
  if (options.liveMalware !== false) {
    if (!jsonOutput) {
      process.stdout.write('üåê Fetching live malware domains from URLhaus... ');
    }

    const liveDomains = await fetchLiveMalwareDomains(30);
    if (liveDomains) {
      domains.malware = liveDomains;
      if (!jsonOutput) {
        console.log(`‚úÖ ${liveDomains.length} domains loaded`);
      }
    } else {
      if (!jsonOutput) {
        console.log('‚ö†Ô∏è  Failed, using static test domains');
      }
    }
  }

  // Run classification
  return classifyResolver(resolverUrl);
})()
  .then(result => {
    // Exit with code based on classification
    if (result.classification === 'unreliable') process.exit(4);
    if (result.classification === 'broken') process.exit(2);
    if (result.classification === 'unknown') process.exit(1);
    process.exit(0);
  })
  .catch(error => {
    console.error('Fatal error:', error);
    process.exit(3);
  });
