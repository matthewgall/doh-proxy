#!/usr/bin/env node

/**
 * DNS Resolver Classification Utility
 *
 * Tests DNS resolvers against a corpus of categorized domains to determine
 * which family (freedom, paranoia, adblock, family) they belong to.
 */

const fs = require('fs');
const path = require('path');
const { Command } = require('commander');
const dnsPacket = require('@dnsquery/dns-packet');

// Load test domains
const DOMAINS_FILE = path.join(__dirname, 'test-domains.json');
const domains = JSON.parse(fs.readFileSync(DOMAINS_FILE, 'utf8'));

// Setup CLI
const program = new Command();

program
  .name('classifyResolver')
  .description('Classify DNS resolvers based on their filtering behavior')
  .version('1.0.0')
  .argument('<resolver-url>', 'DNS resolver URL to test (e.g., https://dns.google/dns-query)')
  .option('-v, --verbose', 'Show detailed output for each domain test', false)
  .option('-p, --protocol <type>', 'Protocol to use (doh or dot)', 'doh')
  .option('-j, --json', 'Output results as JSON', false)
  .option('-t, --timeout <ms>', 'Query timeout in milliseconds', '5000')
  .option('-c, --concurrency <num>', 'Number of parallel queries', '5')
  .addHelpText('after', `
Examples:
  $ classifyResolver https://dns.google/dns-query
  $ classifyResolver https://cloudflare-dns.com/dns-query --verbose
  $ classifyResolver https://family.cloudflare-dns.com/dns-query --json
  $ classifyResolver https://adblock.mydns.network/dns-query -v
`);

program.parse();

const options = program.opts();
const resolverUrl = program.args[0];

// Global options
const verbose = options.verbose;
const jsonOutput = options.json;
const queryTimeout = parseInt(options.timeout);
const concurrency = parseInt(options.concurrency);

// DNS query functions using @dnsquery/dns-packet
async function queryDoH(resolver, domain) {
  try {
    // Create DNS query using dns-packet
    const query = dnsPacket.encode({
      type: 'query',
      id: Math.floor(Math.random() * 65535),
      flags: dnsPacket.RECURSION_DESIRED,
      questions: [{
        type: 'A',
        name: domain
      }]
    });

    const base64Query = Buffer.from(query).toString('base64url');

    const url = new URL(resolver);
    url.searchParams.set('dns', base64Query);

    const response = await fetch(url.toString(), {
      headers: {
        'Accept': 'application/dns-message',
        'User-Agent': 'mydns-classifier/1.0'
      },
      signal: AbortSignal.timeout(queryTimeout)
    });

    if (!response.ok) {
      return { error: `HTTP ${response.status}` };
    }

    const arrayBuffer = await response.arrayBuffer();
    const answer = dnsPacket.decode(Buffer.from(arrayBuffer));

    // Check response code
    if (answer.rcode === 'NXDOMAIN') {
      return { blocked: true, reason: 'NXDOMAIN' };
    }

    if (answer.rcode === 'SERVFAIL') {
      return { blocked: true, reason: 'SERVFAIL' };
    }

    if (answer.rcode !== 'NOERROR') {
      return { blocked: true, reason: `RCODE ${answer.rcode}` };
    }

    // Check if we got answers
    if (!answer.answers || answer.answers.length === 0) {
      return { blocked: true, reason: 'No answer' };
    }

    // Check for block page IPs
    const aRecords = answer.answers.filter(a => a.type === 'A');
    if (aRecords.length > 0) {
      const ip = aRecords[0].data;
      if (ip === '0.0.0.0' || ip === '127.0.0.1' || ip.startsWith('0.') || ip === '::') {
        return { blocked: true, reason: 'Block page IP', ip };
      }
      return { blocked: false, ip };
    }

    return { blocked: false };
  } catch (error) {
    // Distinguish between timeout and other errors
    if (error.name === 'TimeoutError' || error.message.includes('timeout')) {
      return { error: 'Timeout' };
    }
    return { error: error.message };
  }
}

async function testDomain(resolver, domain, category) {
  if (verbose) {
    process.stdout.write(`  Testing ${domain.padEnd(30)} ... `);
  }

  const result = await queryDoH(resolver, domain);

  if (result.error) {
    if (verbose) console.log(`‚ùå Error: ${result.error}`);
    return { domain, category, error: result.error };
  }

  if (verbose) {
    if (result.blocked) {
      console.log(`üö´ Blocked (${result.reason})`);
    } else {
      console.log(`‚úÖ Resolved`);
    }
  }

  return { domain, category, blocked: result.blocked, reason: result.reason };
}

async function classifyResolver(resolver) {
  if (!jsonOutput) {
    console.log(`\nüîç Testing resolver: ${resolver}\n`);
  }

  // Dynamically create results object from domains
  const results = {};
  for (const category of Object.keys(domains)) {
    results[category] = { tested: 0, blocked: 0, errors: 0 };
  }

  const details = [];

  // Test each category (with parallel requests for better performance)
  for (const [category, testDomains] of Object.entries(domains)) {
    if (verbose) console.log(`\nüìã Testing ${category} domains:`);

    // Run queries in parallel batches for optimal performance
    for (let i = 0; i < testDomains.length; i += concurrency) {
      const batch = testDomains.slice(i, i + concurrency);
      const batchResults = await Promise.all(
        batch.map(domain => testDomain(resolver, domain, category))
      );

      // Process results
      for (const result of batchResults) {
        details.push(result);
        results[category].tested++;
        if (result.error) {
          results[category].errors++;
        } else if (result.blocked) {
          results[category].blocked++;
        }
      }
    }
  }

  // Calculate percentages (exclude errors from calculation)
  const percentages = {};
  for (const [category, stats] of Object.entries(results)) {
    const successful = stats.tested - stats.errors;
    // Only calculate if we have enough successful queries
    if (successful >= 3) {
      percentages[category] = (stats.blocked / successful * 100).toFixed(1);
    } else if (successful > 0) {
      // Mark low sample size with negative value
      percentages[category] = -(stats.blocked / successful * 100).toFixed(1);
    } else {
      // No successful queries - can't determine
      percentages[category] = 'N/A';
    }
  }

  // Classify based on blocking patterns
  let classification = 'unknown';
  let confidence = 0;

  // Helper to safely parse percentages (handles 'N/A' and negative values)
  const parsePercentage = (val) => {
    if (val === 'N/A') return 0;
    const num = parseFloat(val);
    return isNaN(num) ? 0 : Math.abs(num);
  };

  // Dynamically parse all percentages into a Map based on available categories
  const blocked = new Map(
    Object.keys(domains).map(category => [
      category,
      parsePercentage(percentages[category])
    ])
  );

  // Check if resolver is broken (blocks legitimate services)
  if (blocked.get('benign') > 20 || blocked.get('cdn') > 20 || blocked.get('streaming') > 30 ||
      blocked.get('news') > 20 || blocked.get('tech') > 20 || blocked.get('ecommerce') > 20 ||
      blocked.get('finance') > 20) {
    classification = 'broken';
    confidence = 'high';
  }
  // Paranoia: blocks tracking heavily, may block some legitimate services
  else if (blocked.get('tracking') >= 80 && blocked.get('social') >= 60 && blocked.get('ads') >= 80) {
    classification = 'paranoia';
    confidence = 'high';
  }
  // Family filtering: blocks adult + gambling + torrents, may block social
  else if (blocked.get('adult') >= 80 && blocked.get('gambling') >= 60 && blocked.get('torrents') >= 60) {
    classification = 'family';
    confidence = 'high';
  }
  // Family filtering (medium confidence): blocks adult content
  else if (blocked.get('adult') >= 80 && blocked.get('gambling') >= 40) {
    classification = 'family';
    confidence = 'medium';
  }
  // Adblock: blocks ads/tracking but not adult content or torrents
  else if (blocked.get('ads') >= 60 && blocked.get('tracking') >= 40 &&
           blocked.get('adult') < 20 && blocked.get('torrents') < 20) {
    classification = 'adblock';
    confidence = 'high';
  }
  // Adblock (medium): blocks some ads/tracking
  else if (blocked.get('ads') >= 40 && blocked.get('adult') < 20) {
    classification = 'adblock';
    confidence = 'medium';
  }
  // Freedom: minimal blocking (only malware/phishing/security)
  else if (blocked.get('adult') < 20 && blocked.get('ads') < 20 && blocked.get('gambling') < 20 &&
           blocked.get('torrents') < 20 && blocked.get('social') < 20) {
    classification = 'freedom';
    confidence = 'high';
  }
  // Unknown: unclear pattern
  else {
    classification = 'unknown';
    confidence = 'low';
  }

  const output = {
    resolver,
    classification,
    confidence,
    percentages,
    results,
    details: jsonOutput ? details : undefined
  };

  if (jsonOutput) {
    console.log(JSON.stringify(output, null, 2));
  } else {
    // Print results
    console.log('\n' + '='.repeat(60));
    console.log('üìä RESULTS');
    console.log('='.repeat(60));
    console.log('');

    // Define category groupings for better organization
    const categoryGroups = {
      'Content Filtering': ['adult', 'gambling', 'torrents'],
      'Privacy & Advertising': ['ads', 'tracking'],
      'Security': ['malware', 'phishing'],
      'Social & Communication': ['social', 'vpn'],
      'Legitimate Services': ['benign', 'cdn', 'streaming', 'news', 'tech', 'ecommerce', 'finance']
    };

    // Display labels for categories
    const categoryLabels = {
      adult: 'Adult',
      gambling: 'Gambling',
      torrents: 'Torrents',
      ads: 'Ads',
      tracking: 'Tracking',
      malware: 'Malware',
      phishing: 'Phishing',
      social: 'Social Media',
      vpn: 'VPN Services',
      benign: 'Benign',
      cdn: 'CDN',
      streaming: 'Streaming',
      news: 'News',
      tech: 'Tech',
      ecommerce: 'E-commerce',
      finance: 'Finance'
    };

    // Find any categories not in predefined groups
    const allGroupedCategories = Object.values(categoryGroups).flat();
    const ungroupedCategories = Object.keys(domains).filter(cat => !allGroupedCategories.includes(cat));
    if (ungroupedCategories.length > 0) {
      categoryGroups['Other'] = ungroupedCategories;
    }

    // Print each group dynamically
    for (const [groupName, categories] of Object.entries(categoryGroups)) {
      console.log(groupName + ':');
      for (const category of categories) {
        if (results[category]) {
          const label = (categoryLabels[category] || category.charAt(0).toUpperCase() + category.slice(1)) + ':';
          const successful = results[category].tested - results[category].errors;
          console.log(`  ${label.padEnd(17)} ${results[category].blocked}/${successful} blocked (${percentages[category]}%)`);
        }
      }
      console.log('');
    }

    console.log(`Classification:  ${classification.toUpperCase()}`);
    console.log(`Confidence:      ${confidence.toUpperCase()}`);
    console.log('');

    // Errors summary
    const totalErrors = Object.values(results).reduce((sum, r) => sum + r.errors, 0);
    const totalTests = Object.values(results).reduce((sum, r) => sum + r.tested, 0);
    const errorRate = ((totalErrors / totalTests) * 100).toFixed(1);

    if (totalErrors > 0) {
      console.log(`‚ö†Ô∏è  ${totalErrors}/${totalTests} queries failed (${errorRate}% error rate)`);
      if (totalErrors > totalTests * 0.3) {
        console.log(`‚ö†Ô∏è  High error rate may affect classification accuracy`);
      }
      console.log('');
    }
  }

  return output;
}

// Run classification
classifyResolver(resolverUrl)
  .then(result => {
    // Exit with code based on classification
    if (result.classification === 'broken') process.exit(2);
    if (result.classification === 'unknown') process.exit(1);
    process.exit(0);
  })
  .catch(error => {
    console.error('Fatal error:', error);
    process.exit(3);
  });
